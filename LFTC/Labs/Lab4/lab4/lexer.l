%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "parser.tab.h"  // Generated by Bison

// Structure for symbol table
struct SymbolEntry {
    char* lexeme;
    int index;
};

// Global variables
extern int yylineno;  // Bison uses this for line tracking
struct SymbolEntry symbol_table[1000];
int symbol_table_size = 0;
FILE* fip_file;
FILE* ts_file;

// Function declarations
int insert_symbol(char* lexeme);
%}

%option yylineno

/* Definitions section */
DIGIT       [0-9]
LETTER      [a-zA-Z]
ID          {LETTER}({LETTER}|{DIGIT}|"_")*
WHITESPACE  [ \t\r]+
CONST_INT   "0"|[1-9]{DIGIT}*
CONST_REAL  {CONST_INT}"."{DIGIT}+
CONST_STR   \"[^\"]*\"

%%
{WHITESPACE}    { /* Ignore whitespace */ }
\n              { /* Handled by yylineno */ }

"int"           { return INT; }
"double"        { return DOUBLE; }
"void"          { return VOID; }
"main"          { return MAIN; }
"cout"          { return COUT; }
"cin"           { return CIN; }
"while"         { return WHILE; }
"if"            { return IF; }
"else"          { return ELSE; }
"endl"          { return ENDL; }
"M_PI"          { return M_PI; }

"+"             { return PLUS; }
"-"             { return MINUS; }
"*"             { return MULT; }
"<<"            { return SHIFT_LEFT; }
">>"            { return SHIFT_RIGHT; }
"="             { return ASSIGN; }
"!="            { return NOT_EQUAL; }
">"             { return GREATER; }
"<"             { return LESS; }
"<="            { return LESS_EQUAL; }
">="            { return GREATER_EQUAL; }
"=="            { return EQUAL; }
"["             { return LEFT_BRACKET; }
"]"             { return RIGHT_BRACKET; }

"("             { return LEFT_PAREN; }
")"             { return RIGHT_PAREN; }
"{"             { return LEFT_BRACE; }
"}"             { return RIGHT_BRACE; }
","             { return COMMA; }
";"             { return SEMICOLON; }

{ID}            { 
    int pos = insert_symbol(yytext);
    yylval.strval = strdup(yytext);  // Save the identifier text
    return ID; 
}

{CONST_INT}     { 
    int pos = insert_symbol(yytext);
    yylval.strval = strdup(yytext);
    if(atoi(yytext) > 0) {
        return CONST_POSITIVE;
    }
    return CONST; 
}

{CONST_REAL}    { 
    int pos = insert_symbol(yytext);
    yylval.strval = strdup(yytext);
    return CONST; 
}

{CONST_STR}     { 
    int pos = insert_symbol(yytext);
    yylval.strval = strdup(yytext);
    return CONST_STRING; 
}

.               { printf("Error at line %d: Unrecognized token '%s'\n", yylineno, yytext); }

%%

int yywrap() {
    return 1;
}

int insert_symbol(char* lexeme) {
    // Check if symbol already exists
    for(int i = 0; i < symbol_table_size; i++) {
        if(strcmp(symbol_table[i].lexeme, lexeme) == 0) {
            return symbol_table[i].index;
        }
    }
    
    // Add new symbol
    symbol_table[symbol_table_size].lexeme = strdup(lexeme);
    symbol_table[symbol_table_size].index = symbol_table_size + 1;
    symbol_table_size++;
    
    return symbol_table_size;
}